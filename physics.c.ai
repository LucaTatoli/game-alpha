#include "physics.h"
#include "utils.h"
#include <float.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

RigidBody *createRigidBody(BodyType type, Vector3 position, Vector3 size) {
	RigidBody *r = xmalloc(sizeof(*r));

	r->type = type;
	r->pos = position;
	r->size = size;
	r->rect = (Rectangle) { 
		.x      = -size.x / 2,
		.y      = -size.y / 2,
		.width  =  size.x / 2,
		.height =  size.y / 2
	};
	
	return r;
}

RigidBody *createRigidBodyFromMesh(BodyType type, Mesh *mesh, Vector3 position) {
	RigidBody *r = xmalloc(sizeof(*r));

	r->type = type;
	r->pos = position;
	r->mesh = mesh;

	float minX =  FLT_MAX, minZ =  FLT_MAX, minY =  FLT_MAX;
	float maxX = -FLT_MAX, maxZ = -FLT_MAX, maxY = -FLT_MAX;
	for(int i = 0; i < mesh->vertexCount; i++) {
		float x = mesh->vertices[i * 3    ];
		float y = mesh->vertices[i * 3 + 1];
		float z = mesh->vertices[i * 3 + 2];

		if(x < minX) minX = x;
		if(x > maxX) maxX = x;
		if(y < minY) minY = y;
		if(y > maxY) maxY = y;
		if(z < minZ) minZ = z;
		if(z > maxZ) maxZ = z;
	}

	r->size = (Vector3) { .x = maxX - minX, .y = maxY - minY, .z = maxZ - minZ };
	r->rect = (Rectangle) {
		.x      = -r->size.x / 2,
		.y      = -r->size.y / 2,
		.width  =  r->size.x / 2,
		.height =  r->size.y / 2
	};

	return r;
}

void freeRigidBody(RigidBody *r) {
	if(r == NULL) {
		fprintf(stderr, "ERROR trying to free an invalid pointer\n");
		exit(1);
	}
	free(r);
}

int checkForCollisionAABB(RigidBody *a, RigidBody *b) {
	if(a == NULL || b == NULL) {
		fprintf(stderr, "ERROR cannot check for collision a NULL pointer to a RigidBody!\n");
		exit(1);
	}
	
	float aMinX, aMaxX, bMinX, bMaxX, aMinY, aMaxY, bMinY, bMaxY;

	aMinX = a->rect.x      + a->pos.x;
	aMaxX = a->rect.width  + a->pos.x;
	bMinX = b->rect.x      + b->pos.x;
	bMaxX = b->rect.width  + b->pos.x;
	aMinY = a->rect.y      + a->pos.z;
	aMaxY = a->rect.height + a->pos.z;
	bMinY = b->rect.y      + b->pos.z;
	bMaxY = b->rect.height + b->pos.z;

	// may be optimized without branching and using only subtractions
	if(((aMinX < bMinX && aMaxX > bMinX) || (aMinX < bMaxX && aMaxX > bMaxX) || (aMinX > bMinX && aMaxX < bMaxX)) &&
	   ((aMinY < bMinY && aMaxY > bMinY) || (aMinY < bMaxY && aMaxY > bMaxY) || (aMinY > bMinY && aMaxY < bMaxY)))
		return 1;
	
	return 0;
}

int checkIfVertexIsInsideBody(RigidBody *a, float vx, float vy, float vz) {
	float minX, maxX, minZ, maxZ, minY, maxY;
	minX = a->rect.x      + a->pos.x;
	maxX = a->rect.width  + a->pos.x;
	minZ = a->rect.y      + a->pos.z;
	maxZ = a->rect.height + a->pos.z;
	minY = a->pos.y - a->size.y / 2;
	maxY = a->pos.y + a->size.y / 2;

	if(vx < minX || vx > maxX || vy < minY || vy > maxY || vz < minZ || vz > maxZ) return 0;

	return 1;
}

int checkIfVertexIsInsideTriangle(float vx, float vy, float vz, float *vertices, int v1, int v2, int v3, Vector3 pos) {
    // Estrai le coordinate dei tre vertici del triangolo
    float ax = vertices[v1 * 3] + pos.x;
    float ay = vertices[v1 * 3 + 1] + pos.y;
    float az = vertices[v1 * 3 + 2] + pos.z;

    float bx = vertices[v2 * 3] + pos.x;
    float by = vertices[v2 * 3 + 1] + pos.y;
    float bz = vertices[v2 * 3 + 2] + pos.z;

    float cx = vertices[v3 * 3] + pos.x;
    float cy = vertices[v3 * 3 + 1] + pos.y;
    float cz = vertices[v3 * 3 + 2] + pos.z;

    // Calcola la normale del piano del triangolo usando il prodotto vettoriale
    float ab_x = bx - ax, ab_y = by - ay, ab_z = bz - az;
    float ac_x = cx - ax, ac_y = cy - ay, ac_z = cz - az;

    float nx = ab_y * ac_z - ab_z * ac_y;
    float ny = ab_z * ac_x - ab_x * ac_z;
    float nz = ab_x * ac_y - ab_y * ac_x;

    // Normalizza la normale
    float n_len = sqrtf(nx*nx + ny*ny + nz*nz);
    if (n_len < 1e-6f) return 0; // Triangolo degenerato
    nx /= n_len; ny /= n_len; nz /= n_len;

    // Verifica se il punto giace sul piano del triangolo
    float d = nx * ax + ny * ay + nz * az;
    float dist = fabsf(nx * vx + ny * vy + nz * vz - d);
    if (dist > 1e-4f) return 0; // Il punto non è sul piano

    // Proietta il punto sul piano del triangolo (per sicurezza)
    float proj_x = vx - nx * dist;
    float proj_y = vy - ny * dist;
    float proj_z = vz - nz * dist;

    // Usa il metodo delle coordinate baricentriche
    // Calcola i vettori dal vertice A agli altri punti
    float v0_x = cx - ax, v0_y = cy - ay, v0_z = cz - az;
    float v1_x = bx - ax, v1_y = by - ay, v1_z = bz - az;
    float v2_x = proj_x - ax, v2_y = proj_y - ay, v2_z = proj_z - az;

    // Calcola i prodotti scalari
    float dot00 = v0_x*v0_x + v0_y*v0_y + v0_z*v0_z;
    float dot01 = v0_x*v1_x + v0_y*v1_y + v0_z*v1_z;
    float dot02 = v0_x*v2_x + v0_y*v2_y + v0_z*v2_z;
    float dot11 = v1_x*v1_x + v1_y*v1_y + v1_z*v1_z;
    float dot12 = v1_x*v2_x + v1_y*v2_y + v1_z*v2_z;

    // Calcola le coordinate baricentriche
    float inv_denom = 1.0f / (dot00 * dot11 - dot01 * dot01);
    float u = (dot11 * dot02 - dot01 * dot12) * inv_denom;
    float v = (dot00 * dot12 - dot01 * dot02) * inv_denom;

    // Verifica se il punto è dentro il triangolo
    return (u >= 0) && (v >= 0) && (u + v <= 1);
}

/* Helper function: calcola l'intersezione di un segmento con un piano */
int segmentPlaneIntersection(float p1x, float p1y, float p1z, float p2x, float p2y, float p2z,
                              float nx, float ny, float nz, float d,
                              float *tx, float *ty, float *tz) {
    float denom = nx * (p2x - p1x) + ny * (p2y - p1y) + nz * (p2z - p1z);
    if (fabsf(denom) < 1e-6f) return 0; // Segmento parallelo al piano

    float t = (d - (nx * p1x + ny * p1y + nz * p1z)) / denom;
    if (t < 0.0f || t > 1.0f) return 0; // Intersezione fuori dal segmento

    *tx = p1x + t * (p2x - p1x);
    *ty = p1y + t * (p2y - p1y);
    *tz = p1z + t * (p2z - p1z);
    return 1;
}

/* Helper function: verifica se un punto 2D è dentro un rettangolo */
int pointInRect(float px, float pz, float minX, float maxX, float minZ, float maxZ) {
    return px >= minX && px <= maxX && pz >= minZ && pz <= maxZ;
}

/* Verifica se un triangolo interseca un corpo AABB */
int triangleAABBIntersection(float *vertices, int v1, int v2, int v3, Vector3 triPos,
                              float minX, float maxX, float minY, float maxY, float minZ, float maxZ) {
    // Coordinate dei vertici del triangolo
    float ax = vertices[v1 * 3] + triPos.x;
    float ay = vertices[v1 * 3 + 1] + triPos.y;
    float az = vertices[v1 * 3 + 2] + triPos.z;

    float bx = vertices[v2 * 3] + triPos.x;
    float by = vertices[v2 * 3 + 1] + triPos.y;
    float bz = vertices[v2 * 3 + 2] + triPos.z;

    float cx = vertices[v3 * 3] + triPos.x;
    float cy = vertices[v3 * 3 + 1] + triPos.y;
    float cz = vertices[v3 * 3 + 2] + triPos.z;

    // Test 1: Verifica se i vertici del triangolo sono dentro l'AABB
    if ((ax >= minX && ax <= maxX && ay >= minY && ay <= maxY && az >= minZ && az <= maxZ) ||
        (bx >= minX && bx <= maxX && by >= minY && by <= maxY && bz >= minZ && bz <= maxZ) ||
        (cx >= minX && cx <= maxX && cy >= minY && cy <= maxY && cz >= minZ && cz <= maxZ)) {
        return 1;
    }

    // Calcola normale e piano del triangolo
    float ab_x = bx - ax, ab_y = by - ay, ab_z = bz - az;
    float ac_x = cx - ax, ac_y = cy - ay, ac_z = cz - az;

    float nx = ab_y * ac_z - ab_z * ac_y;
    float ny = ab_z * ac_x - ab_x * ac_z;
    float nz = ab_x * ac_y - ab_y * ac_x;

    float n_len = sqrtf(nx*nx + ny*ny + nz*nz);
    if (n_len < 1e-6f) return 0;
    nx /= n_len; ny /= n_len; nz /= n_len;

    float d = nx * ax + ny * ay + nz * az;

    // Test 2: Intersezione degli spigoli dell'AABB con il piano del triangolo
    float tx, ty, tz;
    float corners[8][3] = {
        {minX, minY, minZ}, {maxX, minY, minZ}, {minX, maxY, minZ}, {maxX, maxY, minZ},
        {minX, minY, maxZ}, {maxX, minY, maxZ}, {minX, maxY, maxZ}, {maxX, maxY, maxZ}
    };

    int edges[12][2] = {
        {0,1}, {2,3}, {4,5}, {6,7}, // Spigoli paralleli a X
        {0,2}, {1,3}, {4,6}, {5,7}, // Spigoli paralleli a Y
        {0,4}, {1,5}, {2,6}, {3,7}  // Spigoli paralleli a Z
    };

    for (int i = 0; i < 12; i++) {
        int i1 = edges[i][0], i2 = edges[i][1];
        if (segmentPlaneIntersection(
            corners[i1][0], corners[i1][1], corners[i1][2],
            corners[i2][0], corners[i2][1], corners[i2][2],
            nx, ny, nz, d, &tx, &ty, &tz)) {

            // Verifica se il punto di intersezione è dentro il triangolo (coordinate baricentriche)
            float v0_x = cx - ax, v0_y = cy - ay, v0_z = cz - az;
            float v1_x = bx - ax, v1_y = by - ay, v1_z = bz - az;
            float v2_x = tx - ax, v2_y = ty - ay, v2_z = tz - az;

            float dot00 = v0_x*v0_x + v0_y*v0_y + v0_z*v0_z;
            float dot01 = v0_x*v1_x + v0_y*v1_y + v0_z*v1_z;
            float dot02 = v0_x*v2_x + v0_y*v2_y + v0_z*v2_z;
            float dot11 = v1_x*v1_x + v1_y*v1_y + v1_z*v1_z;
            float dot12 = v1_x*v2_x + v1_y*v2_y + v1_z*v2_z;

            float denom = dot00 * dot11 - dot01 * dot01;
            if (fabsf(denom) < 1e-6f) continue;

            float inv_denom = 1.0f / denom;
            float u = (dot11 * dot02 - dot01 * dot12) * inv_denom;
            float v = (dot00 * dot12 - dot01 * dot02) * inv_denom;

            if (u >= 0 && v >= 0 && u + v <= 1) return 1;
        }
    }

    // Test 3: Intersezione dei lati del triangolo con le facce dell'AABB
    float segments[3][2][3] = {
        {{ax, ay, az}, {bx, by, bz}},
        {{bx, by, bz}, {cx, cy, cz}},
        {{cx, cy, cz}, {ax, ay, az}}
    };

    for (int i = 0; i < 3; i++) {
        float sx1 = segments[i][0][0], sy1 = segments[i][0][1], sz1 = segments[i][0][2];
        float sx2 = segments[i][1][0], sy2 = segments[i][1][1], sz2 = segments[i][1][2];

        // Facce X
        if (segmentPlaneIntersection(sx1, sy1, sz1, sx2, sy2, sz2, 1, 0, 0, minX, &tx, &ty, &tz))
            if (ty >= minY && ty <= maxY && tz >= minZ && tz <= maxZ) return 1;
        if (segmentPlaneIntersection(sx1, sy1, sz1, sx2, sy2, sz2, 1, 0, 0, maxX, &tx, &ty, &tz))
            if (ty >= minY && ty <= maxY && tz >= minZ && tz <= maxZ) return 1;

        // Facce Y
        if (segmentPlaneIntersection(sx1, sy1, sz1, sx2, sy2, sz2, 0, 1, 0, minY, &tx, &ty, &tz))
            if (tx >= minX && tx <= maxX && tz >= minZ && tz <= maxZ) return 1;
        if (segmentPlaneIntersection(sx1, sy1, sz1, sx2, sy2, sz2, 0, 1, 0, maxY, &tx, &ty, &tz))
            if (tx >= minX && tx <= maxX && tz >= minZ && tz <= maxZ) return 1;

        // Facce Z
        if (segmentPlaneIntersection(sx1, sy1, sz1, sx2, sy2, sz2, 0, 0, 1, minZ, &tx, &ty, &tz))
            if (tx >= minX && tx <= maxX && ty >= minY && ty <= maxY) return 1;
        if (segmentPlaneIntersection(sx1, sy1, sz1, sx2, sy2, sz2, 0, 0, 1, maxZ, &tx, &ty, &tz))
            if (tx >= minX && tx <= maxX && ty >= minY && ty <= maxY) return 1;
    }

    return 0;
}

/* Versione migliorata di checkForCollisionByHeight */
int checkForCollisionByHeight(RigidBody *a, RigidBody *b) {
    Mesh *bMesh = b->mesh;

    float minX = a->rect.x + a->pos.x;
    float maxX = a->rect.width + a->pos.x;
    float minZ = a->rect.y + a->pos.z;
    float maxZ = a->rect.height + a->pos.z;
    float minY = a->pos.y - a->size.y / 2;
    float maxY = a->pos.y + a->size.y / 2;

    // Verifica ogni triangolo della mesh
    for (int i = 0; i < bMesh->vertexCount; i += 3) {
        if (triangleAABBIntersection(bMesh->vertices, i, i+1, i+2, b->pos,
                                     minX, maxX, minY, maxY, minZ, maxZ)) {
            return 1;
        }
    }

    return 0;
}
